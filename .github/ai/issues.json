{
  "_metadata": {
    "description": "A collection of GitHub issues for the stbl repository.",
    "lookup_key": "issue_number",
    "comment": "Each key in the 'issues' object is a string representation of the GitHub issue number. Empty objects are placeholders so that positions and ids match. Empty objects should be ignored.",
    "updated_at": "2026-02-02T23:05:22Z"
  },
  "issues": {
    "1": [],
    "2": [],
    "3": [],
    "4": [],
    "5": [],
    "6": [],
    "7": [],
    "8": {
      "title": "`named` arg",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "Add an argument to all `stabilize_*()` functions, `named`, with default value `NULL` or maybe `NA`. Its behavior depends on its value:\n\n- `NULL` or `NA` or `character(0)`: Don't check names.\n- `TRUE`: Object must be named, but we don't care what the values are.\n- `FALSE`: Object must not be named.\n- character vector: Object must have these names. Technically it's \"the object must `rlang::is_named2(x), and all names of object must be in this vector\", because we aren't checking length specifically via this argument.\n\nI don't like that I cant stabilize this argument, but this is the best pattern I can think of for interpretation.",
      "comments": []
    },
    "9": [],
    "10": [],
    "11": [],
    "12": [],
    "13": [],
    "14": [],
    "15": [],
    "16": [],
    "17": [],
    "18": [],
    "19": [],
    "20": [],
    "21": [],
    "22": [],
    "23": [],
    "24": [],
    "25": [],
    "26": {
      "title": "stabilize_names()",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "A more complete stabilizer that can confirm precise names, or no duplicates, or that certain names are present, etc.",
      "comments": []
    },
    "27": [],
    "28": [],
    "29": [],
    "30": [],
    "31": [],
    "32": [],
    "33": [],
    "34": [],
    "35": [],
    "36": [],
    "37": [],
    "38": [],
    "39": [],
    "40": [],
    "41": [],
    "42": [],
    "43": [],
    "44": {
      "title": "Export stabilize_cls()?",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "As a developer, I'd like to implement a stbl-style checker for my fancy new class, so that users can get informative error messages for broken bits.\r\n\r\nSee how necessary this is after finishing vctrs setup.",
      "comments": []
    },
    "45": [],
    "46": [],
    "47": [],
    "48": [],
    "49": [],
    "50": [],
    "51": [],
    "52": [],
    "53": {
      "title": "Separate Condition Messages from Signal",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "Errors don't have to be super fast; they'll stop before repeating, so the time won't build up. Focus on making them complete. Collect messages about all possible errors, THEN signal the condition.",
      "comments": ["I don't want to implement this, at least not how I was thinking here.", "Rationale for not doing it: Erroring doesn't have to be fast, but getting through the checks should be. I intentionally code this with a sort of \"stop if you fail, return the good thing if you don't\" philosophy; I'd have to deal with the returns everywhere to see if they have an error in them, and that would get slow and messy.", "Re-consider this specifically for better compatibility with S7. S7 validation should return a character vector with all the reasons for failure, as a sort of incomplete sentence. It might be possible to use `withCallingHandlers()` in a wrapper in order to collect all the would-be error messages (although I think \"downstream\" steps might fail in unexpected ways if we plow through errors, so I'm not sure).\n\nIt might also make sense to make specific versions of `stabilize_*()` and `to_*()` that are focused on this. Maybe `validate_*()` since they'd specifically be used within (S7) validation."]
    },
    "54": [],
    "55": [],
    "56": [],
    "57": [],
    "58": [],
    "59": [],
    "60": [],
    "61": [],
    "62": [],
    "63": [],
    "64": [],
    "65": [],
    "66": {
      "title": "Quotes around bad values in to_fct",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "There's a cli decorator to automatically put `\" \"` around the `Bad values:` list. Do that.",
      "comments": []
    },
    "67": [],
    "68": [],
    "69": [],
    "70": [],
    "71": [],
    "72": [],
    "73": [],
    "74": [],
    "75": [],
    "76": [],
    "77": [],
    "78": [],
    "79": [],
    "80": {
      "title": "JSON schema tix",
      "type": {
        "id": 29398100,
        "node_id": "IT_kwDODjbzj84BwJRU",
        "name": "Task",
        "description": "A specific piece of work",
        "color": "yellow",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "Make tickets for all the json schéma-recognized field types. That's really what this package is about, lean into it. Some might involve packages in Suggests (eg, don't import clock/lubridate if people don't care about dates, probably something similar for urls). ",
      "comments": []
    },
    "81": [],
    "82": [],
    "83": [],
    "84": [],
    "85": [],
    "86": [],
    "87": [],
    "88": [],
    "89": [],
    "90": [],
    "91": [],
    "92": [],
    "93": [],
    "94": [],
    "95": [],
    "96": [],
    "97": [],
    "98": [],
    "99": [],
    "100": [],
    "101": [],
    "102": [],
    "103": [],
    "104": {
      "title": "Stabilize dates",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "Add `to_date()` etc. Will probably use `base::as.Date()`, but maybe check for other date packages (clock, lubridate) when coercion is necessary.",
      "comments": []
    },
    "105": {
      "title": "Stabilize date-times",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "Add `to_dttm()` etc. Will probably use `base::as.POSIXct()`, but maybe check for other date packages (clock, lubridate) when coercion is necessary.",
      "comments": []
    },
    "106": [],
    "107": [],
    "108": [],
    "109": [],
    "110": {
      "title": "Implement `stabilize_lst()`",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 6,
      "body": "(Issue created via conversation with a stbl \"expert\" gem on Google Gemini)\n\n## Overview\n\nWe should add a `stabilize_lst()` function to `{stbl}`. The primary purpose of this function would be to validate the structure and contents of lists, which is a common requirement for functions that accept complex configuration objects.\n\n## API Design\n\nThe key challenge is creating an API that is both powerful enough to handle complex, nested, and heterogeneous lists, but simple enough that it doesn't require users to write complex wrappers.\n\nThe proposed API, which leverages the `specify_*()` function family, distinguishes between checks on the list container and checks on the list elements.\n\n1.  **Container Checks**: Arguments prefixed with a `.` (e.g., `.min_size`, `.max_size`, `.allow_null`) apply to the list object `x` itself.\n2.  **Element Checks**: The API uses an explicit set of rules for validating the elements *within* the list `x`:\n    * **Required Named Elements**: Named `specify_*` functions passed via `...` define validation rules for list elements that *must* be present by that name (e.g., `title = specify_chr_scalar()`).\n    * **Other Named Elements**: The `.named` argument accepts a single `specify_*` function (e.g., `.named = specify_lgl_scalar()`). This function is used to validate all named elements in `x` that are *not* explicitly defined in `...`. If `.named` is `NULL` (the default), any extra named elements will cause an error.\n    * **Unnamed Elements**: The `.unnamed` argument accepts a single `specify_*` function (e.g., `.unnamed = specify_int_scalar()`). This function is used to validate *all* unnamed elements in `x`. If `.unnamed` is `NULL` (the default), any unnamed elements will cause an error.\n\nThis design allows for precise control over list validation, from strictly defined schemas (the default behavior) to more flexible collections of named or unnamed elements.\n\n## Proposed Signature\n\n```r\nstabilize_lst(\n  x,\n  ..., # Named specify_* functions for required named elements\n  .named = NULL, # A single specify_* function for all other named elements\n  .unnamed = NULL, # A single specify_* function for all unnamed elements\n  .allow_null = TRUE,\n  .min_size = NULL,\n  .max_size = NULL,\n  .x_arg = rlang::caller_arg(x),\n  .call = rlang::caller_env(),\n  .x_class = object_type(x)\n)\n\n# New helper specify_* functions to be created\nspecify_lst(...)\nspecify_present(...) (allows any non-NULL)\n```\n\n## Concrete Use Case\n\nA function that builds a plot specification can use `stabilize_lst` to validate its main argument. This example uses `specify_lst()` for nested validation.\n\n```r\ncreate_plot_spec <- function(spec) {\n  # Define specifications for nested elements first\n  spec_aes_coord <- stbl::specify_chr_scalar()\n  spec_aesthetics <- stbl::specify_lst(\n    x = spec_aes_coord,\n    y = spec_aes_coord,\n    # .named = NULL (default) errors on other names (e.g., 'color')\n    # .unnamed = NULL (default) errors on unnamed elements\n    .min_size = 2 # Requires both x and y to be present\n  )\n\n  # Define specifications for top-level elements\n  spec_title <- stbl::specify_chr_scalar(allow_null = FALSE)\n  spec_data <- stbl::specify_present() # Must be present, but can be any non-NULL object\n\n  spec <- stbl::stabilize_lst(\n    spec,\n    # --- Schema for required list elements ---\n    title = spec_title,\n    data = spec_data,\n    aesthetics = spec_aesthetics,\n\n    # --- Rules for the list container itself ---\n    # .named = NULL (default) ensures no extra named elements\n    # .unnamed = NULL (default) ensures no unnamed elements\n    .min_size = 3 # Ensures all three required elements are present\n  )\n\n  # ... function logic now operates on a guaranteed-valid spec object ...\n  return(spec)\n}\n```\n\n## Acceptance Criteria\n\n- Users can validate that a list contains specific, required named elements and that each element passes its own distinct set of rules.\n- Users can validate that all unnamed elements in a list conform to a single, shared set of rules.\n- Users can validate that any \"extra\" named elements (those not explicitly required) all conform to a single, shared set of rules.\n- Users can enforce strict list schemas where any elements not explicitly defined (either as required, unnamed, or extra named) will cause an error.\n- Users can validate complex, nested list structures (e.g., a list that contains other lists, each with their own validation rules).\n- Users can require that a named list element is present and not NULL, without imposing any other type constraints.\n- Users can specify the minimum and/or maximum number of elements in a list.\n- Users can specify whether a list can be `NULL`.\n- Users receive clear, informative error messages that pinpoint which list element failed validation (e.g., \"element `title`\" or \"unnamed element 2\") and what rule it violated.\n",
      "comments": "Make the main function `stabilize_lst()` (etc), and implement `stabilize_list()` (etc) as aliases, I think. Depending how clean that is, consider writing tickets for more aliases, like `stabilize_character()`."
    },
    "111": [],
    "112": [],
    "113": [],
    "114": [],
    "115": [],
    "116": [],
    "117": [],
    "118": [],
    "119": [],
    "120": [],
    "121": [],
    "122": [],
    "123": [],
    "124": [],
    "125": [],
    "126": [],
    "127": [],
    "128": [],
    "129": [],
    "130": [],
    "131": [],
    "132": [],
    "133": [],
    "134": [],
    "135": [],
    "136": [],
    "137": [],
    "138": [],
    "139": [],
    "140": [],
    "141": [],
    "142": {
      "title": "Implement `stabilize_df()`",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 6,
      "body": "> As a {stbl} user, in order to validate the structure and content of a data frame, I would like a `stabilize_df()` function.\n\nThis function will serve as a wrapper around `stabilize_lst()` (#110) to provide specialized checks for data frames. The function should first verify that the input is a data frame and then use `stabilize_lst()` to apply stabilization rules to each column.\n\nKey features should include:\n\n* **Column stabilization**: Use a named list of stabilization functions to apply to each column.\n* **Dimension checks**: Parameters to specify the expected number of rows and columns.\n* **Column name checks**: A parameter to ensure that all expected column names are present.\n\nI can imagine an argument to specify what to do with columns that are too short, but I need to conceptualize how that will work and find examples. Check {tidyr}.",
      "comments": []
    },
    "143": [],
    "144": [],
    "145": [],
    "146": [],
    "147": [],
    "148": [],
    "149": [],
    "150": [],
    "151": [],
    "152": [],
    "153": [],
    "154": [],
    "155": [],
    "156": [],
    "157": [],
    "158": [],
    "159": [],
    "160": [],
    "161": [],
    "162": [],
    "163": [],
    "164": [],
    "165": [],
    "166": [],
    "167": [],
    "168": [],
    "169": [],
    "170": [],
    "171": [],
    "172": [],
    "173": [],
    "174": [],
    "175": {
      "title": "Abstract ai action into separate repo",
      "type": {
        "id": 29398100,
        "node_id": "IT_kwDODjbzj84BwJRU",
        "name": "Task",
        "description": "A specific piece of work",
        "color": "yellow",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": {},
      "body": "I need to learn how to make those, but I think I have the basics over in r4ds.",
      "comments": []
    },
    "176": [],
    "177": [],
    "178": {
      "title": "Custom error message helper",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 6,
      "body": "> As a package author, in order to throw more informative error messages, I'd like to customize error messages.\n\nAdd a function that wraps `tryCatch()` (or `rlang::try_fetch()`) to catch {stbl} conditions and replace the message (and potentially the class). Make sure it's still able to \"remember\" where the call is coming from in the error. This will include documentation updates throughout the package to document what different error classes indicate for each function (maybe in `@returns`?).",
      "comments": []
    },
    "179": [],
    "180": {
      "title": "Fully implement qcthat",
      "type": {
        "id": 29398100,
        "node_id": "IT_kwDODjbzj84BwJRU",
        "name": "Task",
        "description": "A specific piece of work",
        "color": "yellow",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 6,
      "body": "Once [{qcthat}](https://github.com/Gilead-BioStats/qcthat) hits 1.0.0, set it up completely.",
      "comments": []
    },
    "181": [],
    "182": {
      "title": "Implement `to()`",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": {},
      "body": "Add `to()` as a drop-in replacement of `vctrs::vec_cast()`. It's signature should look something like this:\n\n```r\nto(\n  x,\n  .to,\n  ...,\n  x_arg = caller_arg(x),\n  call = caller_env(),\n  x_class = object_type(x)\n)\n```\n\nIt dispatches on `.to`, calling the appropriate `to_*()` function. It should be as fast as I can make it. Consider using S7 for the double dispatch, but do a speed comparison to something like `.to_impl(.to, x, ...)` (it's convenient for `x` to be the first argument of `to()`, but we aren't dispatching on it, so reversing them for dispatch might make sense).\n\nOne goal for this is to use it in `tibblify()` in place of `rvctrs_vec_cast()` (which is used in `src` to call the `vctrs::vec_cast()` function in R; if we can implement an equivalent of this in C and then dispatch to the appropriate R function, that might be enough for now).",
      "comments": []
    },
    "183": [],
    "184": {
      "title": "Profile package and identify C optimization opportunities",
      "type": {
        "id": 29398100,
        "node_id": "IT_kwDODjbzj84BwJRU",
        "name": "Task",
        "description": "A specific piece of work",
        "color": "yellow",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": {},
      "body": "*Issue created with the assistance of an AI agent.*\n\n> As a maintainer, in order to keep stbl performant as the package grows, I would like to profile the package and identify functions that would benefit from C implementations.\n\nWhile the current R implementations work well, there may be opportunities to optimize critical functions with C code — both the fast coercion functions (`to_*()`, `is_*_ish()`, `are_*_ish()`) and the comprehensive validation functions (`stabilize_*()`).\n\n**Proposed approach:**\n\n1. **Profile current performance** — Benchmark core functions with representative inputs of varying sizes\n2. **Identify bottlenecks** — Determine which functions or operations consume the most time\n3. **Prioritize by impact** — Focus on functions where C would provide meaningful speedups\n4. **Create specific issues** — File individual issues for each function identified as a good candidate for C optimization\n\n**Success criteria:**\n- Documented baseline benchmarks for core functions\n- Specific issues created for functions worth optimizing\n- Each follow-up issue includes benchmark targets",
      "comments": []
    }
  }
}
