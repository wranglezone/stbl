{
  "_metadata": {
    "description": "A collection of GitHub issues for the stbl repository.",
    "lookup_key": "issue_number",
    "comment": "Each key in the 'issues' object is a string representation of the GitHub issue number. Empty objects are placeholders so that positions and ids match. Empty objects should be ignored.",
    "updated_at": "2025-11-01T13:46:53Z"
  },
  "issues": {
    "1": [],
    "2": [],
    "3": [],
    "4": [],
    "5": [],
    "6": [],
    "7": [],
    "8": {
      "title": "`named` arg",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "Add an argument to all `stabilize_*()` functions, `named`, with default value `NULL` or maybe `NA`. Its behavior depends on its value:\n\n- `NULL` or `NA` or `character(0)`: Don't check names.\n- `TRUE`: Object must be named, but we don't care what the values are.\n- `FALSE`: Object must not be named.\n- character vector: Object must have these names. Technically it's \"the object must `rlang::is_named2(x), and all names of object must be in this vector\", because we aren't checking length specifically via this argument.\n\nI don't like that I cant stabilize this argument, but this is the best pattern I can think of for interpretation.",
      "comments": []
    },
    "9": [],
    "10": [],
    "11": [],
    "12": [],
    "13": [],
    "14": [],
    "15": [],
    "16": [],
    "17": [],
    "18": [],
    "19": [],
    "20": [],
    "21": [],
    "22": [],
    "23": [],
    "24": [],
    "25": [],
    "26": {
      "title": "stabilize_names()",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "A more complete stabilizer that can confirm precise names, or no duplicates, or that certain names are present, etc.",
      "comments": []
    },
    "27": [],
    "28": [],
    "29": [],
    "30": [],
    "31": [],
    "32": [],
    "33": [],
    "34": [],
    "35": [],
    "36": [],
    "37": [],
    "38": [],
    "39": [],
    "40": [],
    "41": [],
    "42": [],
    "43": [],
    "44": {
      "title": "Export stabilize_cls()?",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "As a developer, I'd like to implement a stbl-style checker for my fancy new class, so that users can get informative error messages for broken bits.\r\n\r\nSee how necessary this is after finishing vctrs setup.",
      "comments": []
    },
    "45": [],
    "46": [],
    "47": [],
    "48": [],
    "49": [],
    "50": [],
    "51": [],
    "52": [],
    "53": [],
    "54": [],
    "55": [],
    "56": [],
    "57": [],
    "58": [],
    "59": [],
    "60": [],
    "61": [],
    "62": [],
    "63": [],
    "64": [],
    "65": [],
    "66": {
      "title": "Quotes around bad values in to_fct",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "There's a cli decorator to automatically put `\" \"` around the `Bad values:` list. Do that.",
      "comments": []
    },
    "67": [],
    "68": [],
    "69": [],
    "70": [],
    "71": [],
    "72": [],
    "73": [],
    "74": [],
    "75": [],
    "76": [],
    "77": [],
    "78": [],
    "79": [],
    "80": {
      "title": "JSON schema tix",
      "type": {
        "id": 29398100,
        "node_id": "IT_kwDODjbzj84BwJRU",
        "name": "Task",
        "description": "A specific piece of work",
        "color": "yellow",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "Make tickets for all the json sch√©ma-recognized field types. That's really what this package is about, lean into it. Some might involve packages in Suggests (eg, don't import clock/lubridate if people don't care about dates, probably something similar for urls). ",
      "comments": []
    },
    "81": [],
    "82": [],
    "83": [],
    "84": [],
    "85": [],
    "86": [],
    "87": [],
    "88": [],
    "89": [],
    "90": [],
    "91": [],
    "92": [],
    "93": [],
    "94": [],
    "95": [],
    "96": [],
    "97": [],
    "98": [],
    "99": [],
    "100": [],
    "101": [],
    "102": [],
    "103": [],
    "104": {
      "title": "Stabilize dates",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "Add `to_date()` etc. Will probably use `base::as.Date()`, but maybe check for other date packages (clock, lubridate) when coercion is necessary.",
      "comments": []
    },
    "105": {
      "title": "Stabilize date-times",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 5,
      "body": "Add `to_dttm()` etc. Will probably use `base::as.POSIXct()`, but maybe check for other date packages (clock, lubridate) when coercion is necessary.",
      "comments": []
    },
    "106": [],
    "107": [],
    "108": [],
    "109": [],
    "110": {
      "title": "Implement `stabilize_lst()`",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 6,
      "body": "(Issue created via conversation with a stbl \"expert\" gem on Google Gemini)\n\n## Overview\n\nWe should add a `stabilize_lst()` function to `{stbl}`. The primary purpose of this function would be to validate the structure and contents of lists, which is a common requirement for functions that accept complex configuration objects.\n\n## API Design\n\nThe key challenge is creating an API that is both powerful enough to handle complex, nested, and heterogeneous lists, but simple enough that it doesn't require users to write complex wrappers.\n\nThe proposed API, which leverages the `specify_*()` function family, distinguishes between checks on the list container and checks on the list elements.\n\n1.  **Container Checks**: Arguments prefixed with a `.` (e.g., `.min_size`, `.max_size`, `.allow_null`) apply to the list object `x` itself.\n2.  **Element Checks**: The API uses an explicit set of rules for validating the elements *within* the list `x`:\n    * **Required Named Elements**: Named `specify_*` functions passed via `...` define validation rules for list elements that *must* be present by that name (e.g., `title = specify_chr_scalar()`).\n    * **Other Named Elements**: The `.named` argument accepts a single `specify_*` function (e.g., `.named = specify_lgl_scalar()`). This function is used to validate all named elements in `x` that are *not* explicitly defined in `...`. If `.named` is `NULL` (the default), any extra named elements will cause an error.\n    * **Unnamed Elements**: The `.unnamed` argument accepts a single `specify_*` function (e.g., `.unnamed = specify_int_scalar()`). This function is used to validate *all* unnamed elements in `x`. If `.unnamed` is `NULL` (the default), any unnamed elements will cause an error.\n\nThis design allows for precise control over list validation, from strictly defined schemas (the default behavior) to more flexible collections of named or unnamed elements.\n\n## Proposed Signature\n\n```r\nstabilize_lst(\n  x,\n  ..., # Named specify_* functions for required named elements\n  .named = NULL, # A single specify_* function for all other named elements\n  .unnamed = NULL, # A single specify_* function for all unnamed elements\n  .allow_null = TRUE,\n  .min_size = NULL,\n  .max_size = NULL,\n  .x_arg = rlang::caller_arg(x),\n  .call = rlang::caller_env(),\n  .x_class = object_type(x)\n)\n\n# New helper specify_* functions to be created\nspecify_lst(...)\nspecify_present(...) (allows any non-NULL)\n```\n\n## Concrete Use Case\n\nA function that builds a plot specification can use `stabilize_lst` to validate its main argument. This example uses `specify_lst()` for nested validation.\n\n```r\ncreate_plot_spec <- function(spec) {\n  # Define specifications for nested elements first\n  spec_aes_coord <- stbl::specify_chr_scalar()\n  spec_aesthetics <- stbl::specify_lst(\n    x = spec_aes_coord,\n    y = spec_aes_coord,\n    # .named = NULL (default) errors on other names (e.g., 'color')\n    # .unnamed = NULL (default) errors on unnamed elements\n    .min_size = 2 # Requires both x and y to be present\n  )\n\n  # Define specifications for top-level elements\n  spec_title <- stbl::specify_chr_scalar(allow_null = FALSE)\n  spec_data <- stbl::specify_present() # Must be present, but can be any non-NULL object\n\n  spec <- stbl::stabilize_lst(\n    spec,\n    # --- Schema for required list elements ---\n    title = spec_title,\n    data = spec_data,\n    aesthetics = spec_aesthetics,\n\n    # --- Rules for the list container itself ---\n    # .named = NULL (default) ensures no extra named elements\n    # .unnamed = NULL (default) ensures no unnamed elements\n    .min_size = 3 # Ensures all three required elements are present\n  )\n\n  # ... function logic now operates on a guaranteed-valid spec object ...\n  return(spec)\n}\n```\n\n## Acceptance Criteria\n\n- Users can validate that a list contains specific, required named elements and that each element passes its own distinct set of rules.\n- Users can validate that all unnamed elements in a list conform to a single, shared set of rules.\n- Users can validate that any \"extra\" named elements (those not explicitly required) all conform to a single, shared set of rules.\n- Users can enforce strict list schemas where any elements not explicitly defined (either as required, unnamed, or extra named) will cause an error.\n- Users can validate complex, nested list structures (e.g., a list that contains other lists, each with their own validation rules).\n- Users can require that a named list element is present and not NULL, without imposing any other type constraints.\n- Users can specify the minimum and/or maximum number of elements in a list.\n- Users can specify whether a list can be `NULL`.\n- Users receive clear, informative error messages that pinpoint which list element failed validation (e.g., \"element `title`\" or \"unnamed element 2\") and what rule it violated.\n",
      "comments": "Make the main function `stabilize_lst()` (etc), and implement `stabilize_list()` (etc) as aliases, I think. Depending how clean that is, consider writing tickets for more aliases, like `stabilize_character()`."
    },
    "111": [],
    "112": [],
    "113": [],
    "114": [],
    "115": [],
    "116": [],
    "117": [],
    "118": [],
    "119": [],
    "120": [],
    "121": [],
    "122": [],
    "123": [],
    "124": [],
    "125": [],
    "126": [],
    "127": [],
    "128": [],
    "129": [],
    "130": [],
    "131": [],
    "132": [],
    "133": [],
    "134": [],
    "135": [],
    "136": [],
    "137": [],
    "138": [],
    "139": [],
    "140": [],
    "141": [],
    "142": {
      "title": "Implement `stabilize_df()`",
      "type": {
        "id": 29398102,
        "node_id": "IT_kwDODjbzj84BwJRW",
        "name": "Feature",
        "description": "A request, idea, or new functionality",
        "color": "blue",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": 6,
      "body": "> As a {stbl} user, in order to validate the structure and content of a data frame, I would like a `stabilize_df()` function.\n\nThis function will serve as a wrapper around `stabilize_lst()` (#110) to provide specialized checks for data frames. The function should first verify that the input is a data frame and then use `stabilize_lst()` to apply stabilization rules to each column.\n\nKey features should include:\n\n* **Column stabilization**: Use a named list of stabilization functions to apply to each column.\n* **Dimension checks**: Parameters to specify the expected number of rows and columns.\n* **Column name checks**: A parameter to ensure that all expected column names are present.\n\nI can imagine an argument to specify what to do with columns that are too short, but I need to conceptualize how that will work and find examples. Check {tidyr}.",
      "comments": []
    },
    "143": [],
    "144": [],
    "145": [],
    "146": [],
    "147": [],
    "148": [],
    "149": [],
    "150": [],
    "151": [],
    "152": [],
    "153": [],
    "154": [],
    "155": [],
    "156": [],
    "157": [],
    "158": [],
    "159": [],
    "160": [],
    "161": [],
    "162": [],
    "163": [],
    "164": [],
    "165": [],
    "166": [],
    "167": [],
    "168": [],
    "169": [],
    "170": [],
    "171": [],
    "172": [],
    "173": [],
    "174": [],
    "175": {
      "title": "Abstract ai action into separate repo",
      "type": {
        "id": 29398100,
        "node_id": "IT_kwDODjbzj84BwJRU",
        "name": "Task",
        "description": "A specific piece of work",
        "color": "yellow",
        "created_at": "2025-10-16T12:35:25Z",
        "updated_at": "2025-10-16T12:35:25Z",
        "is_enabled": true
      },
      "milestone": {},
      "body": "I need to learn how to make those, but I think I have the basics over in r4ds.",
      "comments": []
    }
  }
}
